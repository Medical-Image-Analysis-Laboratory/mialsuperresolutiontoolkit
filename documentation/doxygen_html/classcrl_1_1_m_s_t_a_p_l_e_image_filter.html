<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>crl::MSTAPLEImageFilter&lt; TInputImage, TOutputImage &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="MIALSRTKlogo394x90.png"/></td>
    <td style="padding-left: 0.5em;">
    <div id="projectbrief">C++ image processing tools necessary to perform motion-robust super-resolution fetal MRI reconstruction.</div>
    </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&#160;Structure&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>crl</b></li><li class="navelem"><a class="el" href="classcrl_1_1_m_s_t_a_p_l_e_image_filter.html">MSTAPLEImageFilter</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">crl::MSTAPLEImageFilter&lt; TInputImage, TOutputImage &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The MSTAPLE filter implements the Simultaneous Truth and Performance Level Estimation algorithm for generating ground truth volumes from a set of segmentations.  
 <a href="classcrl_1_1_m_s_t_a_p_l_e_image_filter.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="crl_m_s_t_a_p_l_e_image_filter_8h_source.html">crlMSTAPLEImageFilter.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for crl::MSTAPLEImageFilter&lt; TInputImage, TOutputImage &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcrl_1_1_m_s_t_a_p_l_e_image_filter.png" usemap="#crl::MSTAPLEImageFilter&lt; TInputImage, TOutputImage &gt;_map" alt=""/>
  <map id="crl::MSTAPLEImageFilter&lt; TInputImage, TOutputImage &gt;_map" name="crl::MSTAPLEImageFilter&lt; TInputImage, TOutputImage &gt;_map">
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aeba6e71298699c56db915434d3cc2b14"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classcrl_1_1_m_s_t_a_p_l_e_image_filter.html">MSTAPLEImageFilter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrl_1_1_m_s_t_a_p_l_e_image_filter.html#aeba6e71298699c56db915434d3cc2b14">Self</a></td></tr>
<tr class="memdesc:aeba6e71298699c56db915434d3cc2b14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard class typedefs.  <a href="#aeba6e71298699c56db915434d3cc2b14">More...</a><br/></td></tr>
<tr class="separator:aeba6e71298699c56db915434d3cc2b14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a492e9766b278258379e2910dc27b7628"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a492e9766b278258379e2910dc27b7628"></a>
typedef <br class="typebreak"/>
itk::ImageToImageFilter<br class="typebreak"/>
&lt; TInputImage, TOutputImage &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Superclass</b></td></tr>
<tr class="separator:a492e9766b278258379e2910dc27b7628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a4ac17a8656b24d049da292be49524e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2a4ac17a8656b24d049da292be49524e"></a>
typedef itk::SmartPointer&lt; <a class="el" href="classcrl_1_1_m_s_t_a_p_l_e_image_filter.html#aeba6e71298699c56db915434d3cc2b14">Self</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Pointer</b></td></tr>
<tr class="separator:a2a4ac17a8656b24d049da292be49524e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a332593311fb092c479118dff0ec68bdf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a332593311fb092c479118dff0ec68bdf"></a>
typedef itk::SmartPointer<br class="typebreak"/>
&lt; const <a class="el" href="classcrl_1_1_m_s_t_a_p_l_e_image_filter.html#aeba6e71298699c56db915434d3cc2b14">Self</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ConstPointer</b></td></tr>
<tr class="separator:a332593311fb092c479118dff0ec68bdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3920fb38f666a6a2d813d3a80d86c668"><td class="memItemLeft" align="right" valign="top">typedef TOutputImage::PixelType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrl_1_1_m_s_t_a_p_l_e_image_filter.html#a3920fb38f666a6a2d813d3a80d86c668">OutputPixelType</a></td></tr>
<tr class="memdesc:a3920fb38f666a6a2d813d3a80d86c668"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract some information from the image types.  <a href="#a3920fb38f666a6a2d813d3a80d86c668">More...</a><br/></td></tr>
<tr class="separator:a3920fb38f666a6a2d813d3a80d86c668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d90a283a1d6efa67bf2d34af0ada5c1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0d90a283a1d6efa67bf2d34af0ada5c1"></a>
typedef TInputImage::PixelType&#160;</td><td class="memItemRight" valign="bottom"><b>InputPixelType</b></td></tr>
<tr class="separator:a0d90a283a1d6efa67bf2d34af0ada5c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26b0ee96b56fe7973d6f9a074897403d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a26b0ee96b56fe7973d6f9a074897403d"></a>
typedef itk::NumericTraits<br class="typebreak"/>
&lt; InputPixelType &gt;::RealType&#160;</td><td class="memItemRight" valign="bottom"><b>RealType</b></td></tr>
<tr class="separator:a26b0ee96b56fe7973d6f9a074897403d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9de243b7a2f9ba6ede2a039941890762"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9de243b7a2f9ba6ede2a039941890762"></a>
typedef TInputImage&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrl_1_1_m_s_t_a_p_l_e_image_filter.html#a9de243b7a2f9ba6ede2a039941890762">InputImageType</a></td></tr>
<tr class="memdesc:a9de243b7a2f9ba6ede2a039941890762"><td class="mdescLeft">&#160;</td><td class="mdescRight">Image typedef support. <br/></td></tr>
<tr class="separator:a9de243b7a2f9ba6ede2a039941890762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acacac454f692476800d56b2065ce177f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acacac454f692476800d56b2065ce177f"></a>
typedef TOutputImage&#160;</td><td class="memItemRight" valign="bottom"><b>OutputImageType</b></td></tr>
<tr class="separator:acacac454f692476800d56b2065ce177f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10514efe721989187f94e510c6c193ac"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a10514efe721989187f94e510c6c193ac"></a>
typedef InputImageType::Pointer&#160;</td><td class="memItemRight" valign="bottom"><b>InputImagePointer</b></td></tr>
<tr class="separator:a10514efe721989187f94e510c6c193ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29932954a8048c79743007d7f2a259aa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a29932954a8048c79743007d7f2a259aa"></a>
typedef OutputImageType::Pointer&#160;</td><td class="memItemRight" valign="bottom"><b>OutputImagePointer</b></td></tr>
<tr class="separator:a29932954a8048c79743007d7f2a259aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54f1a9e5665f8f7de95eb46c8d9babfd"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
Superclass::OutputImageRegionType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrl_1_1_m_s_t_a_p_l_e_image_filter.html#a54f1a9e5665f8f7de95eb46c8d9babfd">OutputImageRegionType</a></td></tr>
<tr class="memdesc:a54f1a9e5665f8f7de95eb46c8d9babfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Superclass typedefs.  <a href="#a54f1a9e5665f8f7de95eb46c8d9babfd">More...</a><br/></td></tr>
<tr class="separator:a54f1a9e5665f8f7de95eb46c8d9babfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a73c2247df290cc21060da3b217a1e7bc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrl_1_1_m_s_t_a_p_l_e_image_filter.html#a73c2247df290cc21060da3b217a1e7bc">itkNewMacro</a> (<a class="el" href="classcrl_1_1_m_s_t_a_p_l_e_image_filter.html#aeba6e71298699c56db915434d3cc2b14">Self</a>)</td></tr>
<tr class="memdesc:a73c2247df290cc21060da3b217a1e7bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method for creation through the object factory.  <a href="#a73c2247df290cc21060da3b217a1e7bc">More...</a><br/></td></tr>
<tr class="separator:a73c2247df290cc21060da3b217a1e7bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cfa35c454791c6ecbba2b4453bca116"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8cfa35c454791c6ecbba2b4453bca116"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrl_1_1_m_s_t_a_p_l_e_image_filter.html#a8cfa35c454791c6ecbba2b4453bca116">itkTypeMacro</a> (<a class="el" href="classcrl_1_1_m_s_t_a_p_l_e_image_filter.html">MSTAPLEImageFilter</a>, ImageToImageFilter)</td></tr>
<tr class="memdesc:a8cfa35c454791c6ecbba2b4453bca116"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run-time type information (and related methods) <br/></td></tr>
<tr class="separator:a8cfa35c454791c6ecbba2b4453bca116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d7501204331215426bceb807c3c6278"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrl_1_1_m_s_t_a_p_l_e_image_filter.html#a2d7501204331215426bceb807c3c6278">itkStaticConstMacro</a> (ImageDimension, unsigned int, TOutputImage::ImageDimension)</td></tr>
<tr class="memdesc:a2d7501204331215426bceb807c3c6278"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract some information from the image types.  <a href="#a2d7501204331215426bceb807c3c6278">More...</a><br/></td></tr>
<tr class="separator:a2d7501204331215426bceb807c3c6278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a1e821c7a2e5f48e20204678ff40a51"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2a1e821c7a2e5f48e20204678ff40a51"></a>
const std::vector&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrl_1_1_m_s_t_a_p_l_e_image_filter.html#a2a1e821c7a2e5f48e20204678ff40a51">GetPerformance</a> (unsigned int i) const </td></tr>
<tr class="memdesc:a2a1e821c7a2e5f48e20204678ff40a51"><td class="mdescLeft">&#160;</td><td class="mdescRight">After the filter is updated, this method returns a std::vector&lt;double&gt; encoding the peformance parameter matrix corresponding to one of the input segmentations. <br/></td></tr>
<tr class="separator:a2a1e821c7a2e5f48e20204678ff40a51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbfd148bfe67cd94daaf02eb3e7e3f4c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acbfd148bfe67cd94daaf02eb3e7e3f4c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrl_1_1_m_s_t_a_p_l_e_image_filter.html#acbfd148bfe67cd94daaf02eb3e7e3f4c">SetInitialExpertPerformance</a> (std::vector&lt; double &gt; ondiagonal)</td></tr>
<tr class="memdesc:acbfd148bfe67cd94daaf02eb3e7e3f4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">To enable setting the default initial expert performance parameters for each segmentation generator. <br/></td></tr>
<tr class="separator:acbfd148bfe67cd94daaf02eb3e7e3f4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ecaaad8dd4c1c80e598f059872d6650"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9ecaaad8dd4c1c80e598f059872d6650"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrl_1_1_m_s_t_a_p_l_e_image_filter.html#a9ecaaad8dd4c1c80e598f059872d6650">SetStationaryPrior</a> (std::vector&lt; double &gt; prior)</td></tr>
<tr class="memdesc:a9ecaaad8dd4c1c80e598f059872d6650"><td class="mdescLeft">&#160;</td><td class="mdescRight">To set the stationary prior for each tissue class. <br/></td></tr>
<tr class="separator:a9ecaaad8dd4c1c80e598f059872d6650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3481b5971289bd71b28f12e47ab538da"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3481b5971289bd71b28f12e47ab538da"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>SetInitialExpertPerformanceParameters</b> (std::vector&lt; double &gt; perf)</td></tr>
<tr class="separator:a3481b5971289bd71b28f12e47ab538da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a9ff0f85108db687fd6bf62364a9e47"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrl_1_1_m_s_t_a_p_l_e_image_filter.html#a9a9ff0f85108db687fd6bf62364a9e47">itkSetMacro</a> (MaximumIterations, unsigned int)</td></tr>
<tr class="memdesc:a9a9ff0f85108db687fd6bf62364a9e47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set/Get the maximum number of iterations after which the STAPLE algorithm will be considered to have converged.  <a href="#a9a9ff0f85108db687fd6bf62364a9e47">More...</a><br/></td></tr>
<tr class="separator:a9a9ff0f85108db687fd6bf62364a9e47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af80949a6c4a109979708467242fd0892"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af80949a6c4a109979708467242fd0892"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>itkGetMacro</b> (MaximumIterations, unsigned int)</td></tr>
<tr class="separator:af80949a6c4a109979708467242fd0892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9868b1ed497c8bb63d4330f2026fa87d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9868b1ed497c8bb63d4330f2026fa87d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrl_1_1_m_s_t_a_p_l_e_image_filter.html#a9868b1ed497c8bb63d4330f2026fa87d">itkSetMacro</a> (RelativeConvergenceThreshold, double)</td></tr>
<tr class="memdesc:a9868b1ed497c8bb63d4330f2026fa87d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set/Get the threshold for which a change in the relative magnitude of the mean of the trace of expert performance parameters shall be so small as to trigger termination of the estimation procedure. <br/></td></tr>
<tr class="separator:a9868b1ed497c8bb63d4330f2026fa87d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5701dc5556240878974d11e1d24f3c20"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5701dc5556240878974d11e1d24f3c20"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>itkGetMacro</b> (RelativeConvergenceThreshold, double)</td></tr>
<tr class="separator:a5701dc5556240878974d11e1d24f3c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0d313f3ac9c6bfef83b0274bfca0d47"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af0d313f3ac9c6bfef83b0274bfca0d47"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrl_1_1_m_s_t_a_p_l_e_image_filter.html#af0d313f3ac9c6bfef83b0274bfca0d47">itkSetMacro</a> (StationaryPriorWeight, double)</td></tr>
<tr class="memdesc:af0d313f3ac9c6bfef83b0274bfca0d47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set/Get the weight for the stationary weight. <br/></td></tr>
<tr class="separator:af0d313f3ac9c6bfef83b0274bfca0d47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4565d263e324d52beeff7eb9f2b5541"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad4565d263e324d52beeff7eb9f2b5541"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>itkGetMacro</b> (StationaryPriorWeight, double)</td></tr>
<tr class="separator:ad4565d263e324d52beeff7eb9f2b5541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a485a5287c011baf1aee707a4f303d427"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrl_1_1_m_s_t_a_p_l_e_image_filter.html#a485a5287c011baf1aee707a4f303d427">itkGetMacro</a> (ElapsedIterations, unsigned int)</td></tr>
<tr class="memdesc:a485a5287c011baf1aee707a4f303d427"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of elapsed iterations of the iterative E-M algorithm.  <a href="#a485a5287c011baf1aee707a4f303d427">More...</a><br/></td></tr>
<tr class="separator:a485a5287c011baf1aee707a4f303d427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a663f766a372da547088b4f66a40999cc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrl_1_1_m_s_t_a_p_l_e_image_filter.html#a663f766a372da547088b4f66a40999cc">itkSetMacro</a> (UnderflowProtection, int)</td></tr>
<tr class="memdesc:a663f766a372da547088b4f66a40999cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set/Get the nature of underflow protection to be used.  <a href="#a663f766a372da547088b4f66a40999cc">More...</a><br/></td></tr>
<tr class="separator:a663f766a372da547088b4f66a40999cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8392ca198cc65587f54a4dd286b5992e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8392ca198cc65587f54a4dd286b5992e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>itkGetMacro</b> (UnderflowProtection, int)</td></tr>
<tr class="separator:a8392ca198cc65587f54a4dd286b5992e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd41b1eb8c964dae845988a259095fd3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abd41b1eb8c964dae845988a259095fd3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrl_1_1_m_s_t_a_p_l_e_image_filter.html#abd41b1eb8c964dae845988a259095fd3">itkSetMacro</a> (UseWriteCompression, bool)</td></tr>
<tr class="memdesc:abd41b1eb8c964dae845988a259095fd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set/Get boolean to use or not use (default) compression in output files. <br/></td></tr>
<tr class="separator:abd41b1eb8c964dae845988a259095fd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a321de8f946ce7f26b377628c4377f076"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a321de8f946ce7f26b377628c4377f076"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>itkGetMacro</b> (UseWriteCompression, bool)</td></tr>
<tr class="separator:a321de8f946ce7f26b377628c4377f076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a725f2775935f321954c8aab267e92593"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrl_1_1_m_s_t_a_p_l_e_image_filter.html#a725f2775935f321954c8aab267e92593">itkSetMacro</a> (AssignConsensusVoxels, bool)</td></tr>
<tr class="memdesc:a725f2775935f321954c8aab267e92593"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set/Get boolean to use or not use (default) assign consensus voxels.  <a href="#a725f2775935f321954c8aab267e92593">More...</a><br/></td></tr>
<tr class="separator:a725f2775935f321954c8aab267e92593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f1541965e452e1c4e667485703a60f8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4f1541965e452e1c4e667485703a60f8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>itkGetMacro</b> (AssignConsensusVoxels, bool)</td></tr>
<tr class="separator:a4f1541965e452e1c4e667485703a60f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a315176b37d64905ea7d6c7d16db37c81"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a315176b37d64905ea7d6c7d16db37c81"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrl_1_1_m_s_t_a_p_l_e_image_filter.html#a315176b37d64905ea7d6c7d16db37c81">itkSetMacro</a> (MAPStaple, bool)</td></tr>
<tr class="memdesc:a315176b37d64905ea7d6c7d16db37c81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set/Get boolean to use or not use (default) MAP estimation. <br/></td></tr>
<tr class="separator:a315176b37d64905ea7d6c7d16db37c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c5501139b58c186d3fecedb052e410e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c5501139b58c186d3fecedb052e410e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>itkGetMacro</b> (MAPStaple, bool)</td></tr>
<tr class="separator:a9c5501139b58c186d3fecedb052e410e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28107b67f0bb99302ef39c8237e6fac8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a28107b67f0bb99302ef39c8237e6fac8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrl_1_1_m_s_t_a_p_l_e_image_filter.html#a28107b67f0bb99302ef39c8237e6fac8">itkSetMacro</a> (MAPAlpha, double)</td></tr>
<tr class="memdesc:a28107b67f0bb99302ef39c8237e6fac8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set/Get alpha parameter for MAP estimation. <br/></td></tr>
<tr class="separator:a28107b67f0bb99302ef39c8237e6fac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9b56f5af3fcfca71ee57f5302247d3a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab9b56f5af3fcfca71ee57f5302247d3a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>itkGetMacro</b> (MAPAlpha, double)</td></tr>
<tr class="separator:ab9b56f5af3fcfca71ee57f5302247d3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada6ca0afc71345700332adfaff76163a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ada6ca0afc71345700332adfaff76163a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrl_1_1_m_s_t_a_p_l_e_image_filter.html#ada6ca0afc71345700332adfaff76163a">itkSetMacro</a> (MAPBeta, double)</td></tr>
<tr class="memdesc:ada6ca0afc71345700332adfaff76163a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set/Get beta parameter for MAP estimation. <br/></td></tr>
<tr class="separator:ada6ca0afc71345700332adfaff76163a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ac4bfdc35c4cc522a77a5981bbccee7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ac4bfdc35c4cc522a77a5981bbccee7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>itkGetMacro</b> (MAPBeta, double)</td></tr>
<tr class="separator:a4ac4bfdc35c4cc522a77a5981bbccee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44bd53802b8f8d4abbda41f691943497"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrl_1_1_m_s_t_a_p_l_e_image_filter.html#a44bd53802b8f8d4abbda41f691943497">SetStartAtEStep</a> (bool go)</td></tr>
<tr class="memdesc:a44bd53802b8f8d4abbda41f691943497"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set to true to start with estimating the reference standard.  <a href="#a44bd53802b8f8d4abbda41f691943497">More...</a><br/></td></tr>
<tr class="separator:a44bd53802b8f8d4abbda41f691943497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a726eb6c70a2f4967417dadc8e9d76585"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrl_1_1_m_s_t_a_p_l_e_image_filter.html#a726eb6c70a2f4967417dadc8e9d76585">SetStartAtMStep</a> (bool go)</td></tr>
<tr class="memdesc:a726eb6c70a2f4967417dadc8e9d76585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set to true to start with estimating the performance parameters.  <a href="#a726eb6c70a2f4967417dadc8e9d76585">More...</a><br/></td></tr>
<tr class="separator:a726eb6c70a2f4967417dadc8e9d76585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac9ef8b78e3722412f77148d8e1caa2e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrl_1_1_m_s_t_a_p_l_e_image_filter.html#aac9ef8b78e3722412f77148d8e1caa2e">EstimateReferenceStandard</a> ()</td></tr>
<tr class="memdesc:aac9ef8b78e3722412f77148d8e1caa2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add comment describing purpose of function.  <a href="#aac9ef8b78e3722412f77148d8e1caa2e">More...</a><br/></td></tr>
<tr class="separator:aac9ef8b78e3722412f77148d8e1caa2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7138c577b1fc5c844bcde95a06f7a011"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrl_1_1_m_s_t_a_p_l_e_image_filter.html#a7138c577b1fc5c844bcde95a06f7a011">EstimatePerformanceParameters</a> ()</td></tr>
<tr class="memdesc:a7138c577b1fc5c844bcde95a06f7a011"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add comment describing purpose of function.  <a href="#a7138c577b1fc5c844bcde95a06f7a011">More...</a><br/></td></tr>
<tr class="separator:a7138c577b1fc5c844bcde95a06f7a011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e96593348c66e7faebd188336a13206"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e96593348c66e7faebd188336a13206"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>EstimatePerformanceParametersMAP</b> ()</td></tr>
<tr class="separator:a2e96593348c66e7faebd188336a13206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af581c6c0996353ad6aa7ee294a6d1666"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrl_1_1_m_s_t_a_p_l_e_image_filter.html#af581c6c0996353ad6aa7ee294a6d1666">ExpertPerformanceTraceMean</a> ()</td></tr>
<tr class="memdesc:af581c6c0996353ad6aa7ee294a6d1666"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add comment describing purpose of function.  <a href="#af581c6c0996353ad6aa7ee294a6d1666">More...</a><br/></td></tr>
<tr class="separator:af581c6c0996353ad6aa7ee294a6d1666"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:acacf1b7a1f6c50648cca49a1dd32d280"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acacf1b7a1f6c50648cca49a1dd32d280"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>GenerateData</b> ()</td></tr>
<tr class="separator:acacf1b7a1f6c50648cca49a1dd32d280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cba12b0818b34c84548571ebff9f1d9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4cba12b0818b34c84548571ebff9f1d9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>PrintSelf</b> (std::ostream &amp;, itk::Indent) const </td></tr>
<tr class="separator:a4cba12b0818b34c84548571ebff9f1d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a403043a73f1963c96511f92783b59f25"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a403043a73f1963c96511f92783b59f25"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>PrintExpertPerformance</b> ()</td></tr>
<tr class="separator:a403043a73f1963c96511f92783b59f25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a011e3ab438f66fed0bc3b031d1f3c252"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a011e3ab438f66fed0bc3b031d1f3c252"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>PrintExpertPerformanceSummary</b> ()</td></tr>
<tr class="separator:a011e3ab438f66fed0bc3b031d1f3c252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ab27d2b47c5c8e2e5528ead0a108198"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ab27d2b47c5c8e2e5528ead0a108198"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>PrintExpertPosteriors</b> ()</td></tr>
<tr class="separator:a7ab27d2b47c5c8e2e5528ead0a108198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6c17659d3138378f22e518ef056d504"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab6c17659d3138378f22e518ef056d504"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>GenerateOutputInformation</b> ()</td></tr>
<tr class="separator:ab6c17659d3138378f22e518ef056d504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f22ad580d02284385b6c5011f81ecdc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0f22ad580d02284385b6c5011f81ecdc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>UpdateOutputInformation</b> ()</td></tr>
<tr class="separator:a0f22ad580d02284385b6c5011f81ecdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename TInputImage, typename TOutputImage&gt;<br/>
class crl::MSTAPLEImageFilter&lt; TInputImage, TOutputImage &gt;</h3>

<p>The MSTAPLE filter implements the Simultaneous Truth and Performance Level Estimation algorithm for generating ground truth volumes from a set of segmentations. </p>
<p>The segmentations may consist of binary labels, or any finite number of categories.</p>
<p>The STAPLE algorithm estimates a probabilistic reference standard for the true segmentation of an image from a collection of segmentations by experts or algorithms. The reference standard is obtained by an optimal weighting of the input segmentations, and the algorithm also identifies the optimal weights. The reference standard produced by this filter is a set of floating point volumes of values between zero and one that indicate probability of each pixel having a particular label.</p>
<p>The STAPLE algorithm is described in</p>
<p>S. Warfield, K. Zou, W. Wells, "Validation of image segmentation and expert
quality with an expectation-maximization algorithm" in MICCAI 2002: Fifth International Conference on Medical Image Computing and Computer-Assisted Intervention, Springer-Verlag, Heidelberg, Germany, 2002, pp. 298-306</p>
<p>The multi-label version of the algorithm is described in Warfield, Zou, Wells IEEE TMI 2004.</p>
<dl class="section user"><dt>INPUTS</dt><dd>Input volumes to the STAPLE filter must be segmentations of the same image. That is, there must be consistent set of label values and a consistent geometry for each input image.</dd></dl>
<p>Input volumes must all contain the same size RequestedRegions.</p>
<dl class="section user"><dt>OUTPUTS</dt><dd>The STAPLE filter produces a single output volume with a range of floating point values from zero to one. IT IS VERY IMPORTANT TO INSTANTIATE THIS FILTER WITH A FLOATING POINT OUTPUT TYPE (floats or doubles). You may select the index of the component with the largest value if you wish to produce an image of discrete labels as output.</dd></dl>
<dl class="section user"><dt>PARAMETERS</dt><dd>The STAPLE algorithm requires a number of inputs. You may specify any number of input volumes using the SetInput(i, p_i) method, where i ranges from zero to N-1, N is the total number of input segmentations, and p_i is the SmartPointer to the i-th segmentation.</dd></dl>
<p>The STAPLE algorithm is an iterative Expectation-Maximization algorithm and will converge on a solution after some number of iterations that cannot be known a priori. After updating the filter, the total elapsed iterations taken to converge on the solution can be queried through GetElapsedIterations(). You may also specify a MaximumNumberOfIterations, after which the algorithm will stop iterating regardless of whether or not it has converged. This implementation of the STAPLE algorithm will find the solution to within seven digits of precision unless it is stopped early.</p>
<p>Once updated, the performance rates for each rater input volume can be queried using GetPerformance(i), where i is the i-th input volume.</p>
<dl class="section user"><dt>REQUIRED PARAMETERS</dt><dd>The only required parameters for this filter are the input volumes. All other parameters may be safely left to their default values. Please see the paper cited above for more information on the STAPLE algorithm and its parameters. A proper understanding of the algorithm is important for interpreting the results that it produces.</dd></dl>
<dl class="section user"><dt>EVENTS</dt><dd>This filter invokes IterationEvent() at each iteration of the E-M algorithm. Setting the AbortGenerateData() flag will cause the algorithm to halt after the current iteration and produce results just as if it had converged. The algorithm makes no attempt to report its progress since the number of iterations needed cannot be known in advance. </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a54f1a9e5665f8f7de95eb46c8d9babfd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TInputImage , typename TOutputImage &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Superclass::OutputImageRegionType <a class="el" href="classcrl_1_1_m_s_t_a_p_l_e_image_filter.html">crl::MSTAPLEImageFilter</a>&lt; TInputImage, TOutputImage &gt;::<a class="el" href="classcrl_1_1_m_s_t_a_p_l_e_image_filter.html#a54f1a9e5665f8f7de95eb46c8d9babfd">OutputImageRegionType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Superclass typedefs. </p>

</div>
</div>
<a class="anchor" id="a3920fb38f666a6a2d813d3a80d86c668"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TInputImage , typename TOutputImage &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef TOutputImage::PixelType <a class="el" href="classcrl_1_1_m_s_t_a_p_l_e_image_filter.html">crl::MSTAPLEImageFilter</a>&lt; TInputImage, TOutputImage &gt;::<a class="el" href="classcrl_1_1_m_s_t_a_p_l_e_image_filter.html#a3920fb38f666a6a2d813d3a80d86c668">OutputPixelType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract some information from the image types. </p>
<p>Dimensionality of the two images is assumed to be the same. </p>

</div>
</div>
<a class="anchor" id="aeba6e71298699c56db915434d3cc2b14"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TInputImage , typename TOutputImage &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classcrl_1_1_m_s_t_a_p_l_e_image_filter.html">MSTAPLEImageFilter</a> <a class="el" href="classcrl_1_1_m_s_t_a_p_l_e_image_filter.html">crl::MSTAPLEImageFilter</a>&lt; TInputImage, TOutputImage &gt;::<a class="el" href="classcrl_1_1_m_s_t_a_p_l_e_image_filter.html#aeba6e71298699c56db915434d3cc2b14">Self</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Standard class typedefs. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a7138c577b1fc5c844bcde95a06f7a011"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TInputImage , typename TOutputImage &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcrl_1_1_m_s_t_a_p_l_e_image_filter.html">crl::MSTAPLEImageFilter</a>&lt; TInputImage, TOutputImage &gt;::EstimatePerformanceParameters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add comment describing purpose of function. </p>

</div>
</div>
<a class="anchor" id="aac9ef8b78e3722412f77148d8e1caa2e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TInputImage , typename TOutputImage &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcrl_1_1_m_s_t_a_p_l_e_image_filter.html">crl::MSTAPLEImageFilter</a>&lt; TInputImage, TOutputImage &gt;::EstimateReferenceStandard </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add comment describing purpose of function. </p>

</div>
</div>
<a class="anchor" id="af581c6c0996353ad6aa7ee294a6d1666"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TInputImage , typename TOutputImage &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classcrl_1_1_m_s_t_a_p_l_e_image_filter.html">crl::MSTAPLEImageFilter</a>&lt; TInputImage, TOutputImage &gt;::ExpertPerformanceTraceMean </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add comment describing purpose of function. </p>

</div>
</div>
<a class="anchor" id="a485a5287c011baf1aee707a4f303d427"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TInputImage , typename TOutputImage &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcrl_1_1_m_s_t_a_p_l_e_image_filter.html">crl::MSTAPLEImageFilter</a>&lt; TInputImage, TOutputImage &gt;::itkGetMacro </td>
          <td>(</td>
          <td class="paramtype">ElapsedIterations&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>int</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of elapsed iterations of the iterative E-M algorithm. </p>

</div>
</div>
<a class="anchor" id="a73c2247df290cc21060da3b217a1e7bc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TInputImage , typename TOutputImage &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcrl_1_1_m_s_t_a_p_l_e_image_filter.html">crl::MSTAPLEImageFilter</a>&lt; TInputImage, TOutputImage &gt;::itkNewMacro </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcrl_1_1_m_s_t_a_p_l_e_image_filter.html#aeba6e71298699c56db915434d3cc2b14">Self</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method for creation through the object factory. </p>

</div>
</div>
<a class="anchor" id="a9a9ff0f85108db687fd6bf62364a9e47"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TInputImage , typename TOutputImage &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcrl_1_1_m_s_t_a_p_l_e_image_filter.html">crl::MSTAPLEImageFilter</a>&lt; TInputImage, TOutputImage &gt;::itkSetMacro </td>
          <td>(</td>
          <td class="paramtype">MaximumIterations&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>int</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set/Get the maximum number of iterations after which the STAPLE algorithm will be considered to have converged. </p>
<p>In general this SHOULD NOT be set and the algorithm should be allowed to converge on its own. </p>

</div>
</div>
<a class="anchor" id="a663f766a372da547088b4f66a40999cc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TInputImage , typename TOutputImage &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcrl_1_1_m_s_t_a_p_l_e_image_filter.html">crl::MSTAPLEImageFilter</a>&lt; TInputImage, TOutputImage &gt;::itkSetMacro </td>
          <td>(</td>
          <td class="paramtype">UnderflowProtection&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set/Get the nature of underflow protection to be used. </p>
<p>Underflow protection is computationally expensive but important when a large number of raters are being used. The default value is 0 which does straightforward calculations, 1 represents strong underflow protection, and 2 is extreme underflow protection. </p>

</div>
</div>
<a class="anchor" id="a725f2775935f321954c8aab267e92593"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TInputImage , typename TOutputImage &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcrl_1_1_m_s_t_a_p_l_e_image_filter.html">crl::MSTAPLEImageFilter</a>&lt; TInputImage, TOutputImage &gt;::itkSetMacro </td>
          <td>(</td>
          <td class="paramtype">AssignConsensusVoxels&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set/Get boolean to use or not use (default) assign consensus voxels. </p>
<p>All voxels that have been labelled the same by every input segmentation are assigned that label, and skipped in the computation of segmentation performance. </p>

</div>
</div>
<a class="anchor" id="a2d7501204331215426bceb807c3c6278"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TInputImage , typename TOutputImage &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcrl_1_1_m_s_t_a_p_l_e_image_filter.html">crl::MSTAPLEImageFilter</a>&lt; TInputImage, TOutputImage &gt;::itkStaticConstMacro </td>
          <td>(</td>
          <td class="paramtype">ImageDimension&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>int</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOutputImage::ImageDimension&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract some information from the image types. </p>
<p>Dimensionality of the two images is assumed to be the same. </p>

</div>
</div>
<a class="anchor" id="a44bd53802b8f8d4abbda41f691943497"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TInputImage , typename TOutputImage &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcrl_1_1_m_s_t_a_p_l_e_image_filter.html">crl::MSTAPLEImageFilter</a>&lt; TInputImage, TOutputImage &gt;::SetStartAtEStep </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>go</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set to true to start with estimating the reference standard. </p>
<p>This means we initialize with the performance parameters. </p>

</div>
</div>
<a class="anchor" id="a726eb6c70a2f4967417dadc8e9d76585"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TInputImage , typename TOutputImage &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcrl_1_1_m_s_t_a_p_l_e_image_filter.html">crl::MSTAPLEImageFilter</a>&lt; TInputImage, TOutputImage &gt;::SetStartAtMStep </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>go</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set to true to start with estimating the performance parameters. </p>
<p>This means we initialize with the reference standard. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/Code/CRKit/<a class="el" href="crl_m_s_t_a_p_l_e_image_filter_8h_source.html">crlMSTAPLEImageFilter.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Jul 5 2017 22:26:58 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
